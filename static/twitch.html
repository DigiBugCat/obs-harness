<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Integration</title>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent: #9146ff;
            --accent-hover: #a970ff;
            --success: #4ecca3;
            --warning: #ffc107;
            --error: #e94560;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--bg-card);
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .back-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.875rem;
        }

        .back-link:hover {
            color: var(--text-primary);
        }

        .card {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .status-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--warning);
        }

        .status-dot.connected {
            background: var(--success);
        }

        .status-text {
            color: var(--text-secondary);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--bg-secondary);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .info-value {
            color: var(--accent);
            font-weight: 500;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--bg-secondary);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1rem;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-twitch {
            background: var(--accent);
            color: white;
            width: 100%;
        }

        .btn-twitch:hover {
            background: var(--accent-hover);
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #ff6b6b;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            width: 100%;
        }

        .btn-secondary:hover {
            background: var(--bg-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-row {
            display: flex;
            gap: 0.5rem;
        }

        .button-row .btn {
            flex: 1;
        }

        .message {
            color: var(--success);
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(78, 204, 163, 0.1);
            border-radius: 6px;
        }

        .error {
            color: var(--error);
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: rgba(233, 69, 96, 0.1);
            border-radius: 6px;
        }

        .hidden {
            display: none;
        }

        .twitch-logo {
            width: 20px;
            height: 20px;
        }

        .section-description {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Twitch Integration</h1>
            <a href="/" class="back-link">Back to Dashboard</a>
        </header>

        <div id="message" class="message hidden"></div>
        <div id="error" class="error hidden"></div>

        <!-- Login Section -->
        <div class="card">
            <div class="card-title">1. Login to Twitch</div>
            <p class="section-description">
                Login with your Twitch account to enable EventSub for channel point redemptions.
            </p>

            <div id="not-logged-in" class="hidden">
                <button id="login-btn" class="btn btn-twitch">
                    <svg class="twitch-logo" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M11.571 4.714h1.715v5.143H11.57zm4.715 0H18v5.143h-1.714zM6 0L1.714 4.286v15.428h5.143V24l4.286-4.286h3.428L22.286 12V0zm14.571 11.143l-3.428 3.428h-3.429l-3 3v-3H6.857V1.714h13.714Z"/>
                    </svg>
                    Login with Twitch
                </button>
            </div>

            <div id="logged-in" class="hidden">
                <div class="info-row">
                    <span class="info-label">Logged in as</span>
                    <span class="info-value" id="username-display">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">User ID</span>
                    <span class="info-value" id="user-id-display">-</span>
                </div>
                <button id="logout-btn" class="btn btn-danger" style="margin-top: 1rem; width: 100%;">Logout</button>
            </div>
        </div>

        <!-- Channel Section -->
        <div class="card">
            <div class="card-title">2. Chat Channel to Monitor</div>
            <p class="section-description">
                Choose which channel's chat to read. This can be different from the logged-in account.
            </p>

            <div class="status-row">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text" class="status-text">Not connected</span>
            </div>

            <div class="form-group">
                <label for="channel">Channel name (without #)</label>
                <input type="text" id="channel" placeholder="channelname">
            </div>
            <button id="connect-btn" class="btn btn-secondary">Connect to Channel</button>
        </div>

        <!-- Chat Preview -->
        <div id="preview-section" class="card hidden">
            <div class="card-title">Recent Chat (Last 60 seconds)</div>
            <div id="chat-preview" style="background: var(--bg-secondary); border-radius: 6px; padding: 1rem; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 0.875rem; white-space: pre-wrap; color: var(--text-secondary);"></div>
            <button id="refresh-btn" class="btn btn-secondary" style="margin-top: 1rem;">Refresh</button>
        </div>
    </div>

    <script>
        // Twitch OAuth config
        const CLIENT_ID = 'h1x5odjr6qy1m8sesgev1p9wcssz63';
        const REDIRECT_URI = window.location.origin + '/auth/callback';
        const SCOPES = [
            'chat:read',
            'user:read:chat',  // Required for EventSub chat subscription
            'channel:read:redemptions',
            'channel:manage:redemptions'
        ].join(' ');

        // DOM elements
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const notLoggedIn = document.getElementById('not-logged-in');
        const loggedIn = document.getElementById('logged-in');
        const usernameDisplay = document.getElementById('username-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const channelInput = document.getElementById('channel');
        const previewSection = document.getElementById('preview-section');
        const messageEl = document.getElementById('message');
        const errorEl = document.getElementById('error');

        // WebSocket connection for real-time chat
        let chatWs = null;
        let chatMessages = [];  // Store messages for display
        const MAX_MESSAGES = 50;  // Max messages to keep in buffer

        // Check if we're returning from OAuth
        async function handleOAuthCallback() {
            const hash = window.location.hash;
            if (!hash) return;

            const params = new URLSearchParams(hash.substring(1));
            const accessToken = params.get('access_token');

            if (!accessToken) return;

            // Clear the hash from URL
            history.replaceState(null, '', window.location.pathname);

            try {
                // Fetch user info from Twitch
                const userResponse = await fetch('https://api.twitch.tv/helix/users', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': CLIENT_ID
                    }
                });

                if (!userResponse.ok) {
                    throw new Error('Failed to get user info from Twitch');
                }

                const userData = await userResponse.json();
                const user = userData.data[0];

                // Get current channel (use logged-in user's channel as default)
                const channel = channelInput.value.trim() || user.login;

                // Save to backend
                const response = await fetch('/api/twitch/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        access_token: accessToken,
                        user_id: user.id,
                        username: user.login,
                        channel: channel
                    })
                });

                if (response.ok) {
                    showMessage(`Logged in as ${user.display_name}!`);
                    await checkStatus();
                } else {
                    const data = await response.json();
                    showError(data.detail || 'Failed to save token');
                }
            } catch (e) {
                showError('OAuth error: ' + e.message);
            }
        }

        // Check connection status
        async function checkStatus() {
            try {
                const response = await fetch('/api/twitch/status');
                const data = await response.json();

                // Update login status
                if (data.user_id) {
                    notLoggedIn.classList.add('hidden');
                    loggedIn.classList.remove('hidden');
                    usernameDisplay.textContent = data.username || '-';
                    userIdDisplay.textContent = data.user_id || '-';
                } else {
                    notLoggedIn.classList.remove('hidden');
                    loggedIn.classList.add('hidden');
                }

                // Update connection status
                if (data.connected) {
                    statusDot.classList.add('connected');
                    statusText.textContent = `Connected to #${data.channel} (EventSub)`;
                    channelInput.value = data.channel;
                    previewSection.classList.remove('hidden');

                    // Connect WebSocket and fetch initial chat history
                    connectChatWebSocket();
                    refreshChat();
                } else {
                    statusDot.classList.remove('connected');
                    statusText.textContent = 'Not connected';
                    previewSection.classList.add('hidden');
                    disconnectChatWebSocket();
                }
            } catch (e) {
                statusText.textContent = 'Error checking status';
                showError('Failed to check status: ' + e.message);
            }
        }

        // Start OAuth flow
        function login() {
            const authUrl = `https://id.twitch.tv/oauth2/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=token&scope=${encodeURIComponent(SCOPES)}`;
            window.location.href = authUrl;
        }

        // Logout
        async function logout() {
            try {
                disconnectChatWebSocket();
                const response = await fetch('/api/twitch/disconnect', { method: 'POST' });
                if (response.ok) {
                    showMessage('Logged out');
                    await checkStatus();
                }
            } catch (e) {
                showError('Failed to logout: ' + e.message);
            }
        }

        // Connect to channel
        async function connectToChannel() {
            const channel = channelInput.value.trim().toLowerCase();
            if (!channel) {
                showError('Please enter a channel name');
                return;
            }

            try {
                const response = await fetch('/api/twitch/channel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ channel: channel })
                });

                if (response.ok) {
                    showMessage('Connected to #' + channel);
                    await checkStatus();
                } else {
                    const data = await response.json();
                    showError(data.detail || 'Failed to connect');
                }
            } catch (e) {
                showError('Failed to connect: ' + e.message);
            }
        }

        // Connect to chat WebSocket for real-time updates
        function connectChatWebSocket() {
            if (chatWs && chatWs.readyState === WebSocket.OPEN) {
                return;  // Already connected
            }

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/twitch/chat`;

            chatWs = new WebSocket(wsUrl);

            chatWs.onopen = () => {
                console.log('Chat WebSocket connected');
            };

            chatWs.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (data.type === 'chat_message') {
                        // Add new message to buffer
                        chatMessages.push(data.message);
                        if (chatMessages.length > MAX_MESSAGES) {
                            chatMessages.shift();  // Remove oldest
                        }
                        updateChatDisplay();
                    } else if (data.type === 'connected') {
                        console.log('Chat WebSocket status:', data);
                    }
                } catch (e) {
                    console.error('Failed to parse chat message:', e);
                }
            };

            chatWs.onclose = () => {
                console.log('Chat WebSocket disconnected');
                // Reconnect after a delay if preview section is visible
                setTimeout(() => {
                    if (!previewSection.classList.contains('hidden')) {
                        connectChatWebSocket();
                    }
                }, 3000);
            };

            chatWs.onerror = (e) => {
                console.error('Chat WebSocket error:', e);
            };
        }

        // Disconnect chat WebSocket
        function disconnectChatWebSocket() {
            if (chatWs) {
                chatWs.close();
                chatWs = null;
            }
            chatMessages = [];
        }

        // Update the chat display from buffered messages
        function updateChatDisplay() {
            const chatPreview = document.getElementById('chat-preview');
            if (chatMessages.length === 0) {
                chatPreview.textContent = 'No recent messages...';
            } else {
                chatPreview.textContent = chatMessages
                    .map(m => `[${m.user}]: ${m.text}`)
                    .join('\n');
                // Auto-scroll to bottom
                chatPreview.scrollTop = chatPreview.scrollHeight;
            }
        }

        // Refresh chat preview (fetch initial history)
        async function refreshChat() {
            try {
                const response = await fetch('/api/twitch/chat?seconds=60');
                const data = await response.json();

                // Parse the context into messages if using fallback
                if (data.context) {
                    // The context is a formatted string like "[user]: message\n[user2]: message2"
                    const lines = data.context.split('\n').filter(l => l.trim());
                    chatMessages = lines.map(line => {
                        const match = line.match(/^\[([^\]]+)\]:\s*(.*)$/);
                        if (match) {
                            return { user: match[1], text: match[2] };
                        }
                        return { user: '?', text: line };
                    });
                } else {
                    chatMessages = [];
                }
                updateChatDisplay();

                // Show data source
                console.log('Chat source:', data.source);
            } catch (e) {
                console.error('Failed to load chat:', e);
            }
        }

        // Show message
        function showMessage(text) {
            messageEl.textContent = text;
            messageEl.classList.remove('hidden');
            errorEl.classList.add('hidden');
            setTimeout(() => messageEl.classList.add('hidden'), 5000);
        }

        // Show error
        function showError(text) {
            errorEl.textContent = text;
            errorEl.classList.remove('hidden');
            messageEl.classList.add('hidden');
            setTimeout(() => errorEl.classList.add('hidden'), 5000);
        }

        // Event listeners
        document.getElementById('login-btn').addEventListener('click', login);
        document.getElementById('logout-btn').addEventListener('click', logout);
        document.getElementById('connect-btn').addEventListener('click', connectToChannel);
        document.getElementById('refresh-btn').addEventListener('click', refreshChat);
        channelInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') connectToChannel();
        });

        // Initialize
        handleOAuthCallback();
        checkStatus();

        // WebSocket handles real-time updates, no polling needed
        // Keep refresh button for manual refresh of historical messages
    </script>
</body>
</html>
